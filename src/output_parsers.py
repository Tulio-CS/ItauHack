"""Utility classes to parse and validate LLM structured outputs."""
from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from typing import Iterable, MutableMapping, Optional

logger = logging.getLogger(__name__)


class OutputParserError(ValueError):
    """Exception raised when the LLM output cannot be parsed."""


def extract_json_blob(response: str) -> Optional[str]:
    """Extract the first JSON object found inside ``response``.

    Parameters
    ----------
    response:
        Raw text generated by the LLM.

    Returns
    -------
    Optional[str]
        A JSON string containing a single object when one is detected,
        otherwise ``None``.
    """

    if not response:
        return None

    stripped = response.strip()
    if stripped.startswith("{") and stripped.endswith("}"):
        return stripped

    start = stripped.find("{")
    if start == -1:
        return None

    depth = 0
    for idx in range(start, len(stripped)):
        char = stripped[idx]
        if char == "{":
            depth += 1
        elif char == "}":
            depth -= 1
            if depth == 0:
                return stripped[start : idx + 1]

    logger.debug("Unbalanced JSON braces detected", extra={"raw_response": response})
    return None


@dataclass
class JsonOutputParser:
    """Parse LLM outputs expecting a JSON object with required keys."""

    required_keys: Iterable[str] = field(default_factory=tuple)
    allow_partial: bool = False

    def parse(self, response: str) -> MutableMapping[str, object]:
        json_blob = extract_json_blob(response)
        if json_blob is None:
            raise OutputParserError("No JSON object detected in LLM response")

        try:
            payload = json.loads(json_blob)
        except json.JSONDecodeError as exc:  # pragma: no cover - defensive
            raise OutputParserError("Invalid JSON returned by LLM") from exc

        if not isinstance(payload, MutableMapping):
            raise OutputParserError("LLM JSON root must be an object")

        missing = [key for key in self.required_keys if key not in payload]
        if missing and not self.allow_partial:
            raise OutputParserError(f"Missing keys in LLM JSON: {missing}")

        return payload
